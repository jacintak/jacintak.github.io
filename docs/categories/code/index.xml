<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>code | Jacinta&#39;s Website</title>
    <link>https://jacintak.github.io/categories/code/</link>
      <atom:link href="https://jacintak.github.io/categories/code/index.xml" rel="self" type="application/rss+xml" />
    <description>code</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Tue, 01 Jun 2021 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://jacintak.github.io/img/icon-512.png</url>
      <title>code</title>
      <link>https://jacintak.github.io/categories/code/</link>
    </image>
    
    <item>
      <title>R Club: Functions &amp; Loops</title>
      <link>https://jacintak.github.io/post/2021-06-01-r-function-loops/</link>
      <pubDate>Tue, 01 Jun 2021 00:00:00 +0000</pubDate>
      <guid>https://jacintak.github.io/post/2021-06-01-r-function-loops/</guid>
      <description>
&lt;script src=&#34;https://jacintak.github.io/post/2021-06-01-r-function-loops/index_files/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;p&gt;This tutorial was originally presented to NERD club on 18/11/2020.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;This document contains two examples of functions and an example of how functions can be integrated with loops.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;User defined functions take the general form of &lt;code&gt;function(inputs){processing inputs; return(output)}&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div id=&#34;predator-prey-interactions&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Predator-Prey interactions&lt;/h1&gt;
&lt;p&gt;We will use a simulation of predator-prey interactions as an example. Predator-prey interactions simulate how many prey a predator can capture after a specific amount of time and for a given density of prey. We use this example with undergraduate biology students to demonstrate statistical modelling, experimental design and collecting data.&lt;/p&gt;
&lt;p&gt;Normally we would get students to do this laboratory practical in class by picking up counters and putting them in jars while blindfolded. We can also see whether the use of different types of jars affects the efficiency of the predator. This is the experimental design:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Response variable - Number of prey caught (&lt;code&gt;Ha&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Total foraging time - 1 minute, a constant (&lt;code&gt;T&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Predictor variables:
&lt;ul&gt;
&lt;li&gt;Prey density - user defined treatments (&lt;code&gt;H&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Type of jar used - jar with a lid or no lid (&lt;code&gt;yes&lt;/code&gt; or &lt;code&gt;no&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Normally the students will collect data to parameterise the functional response. Instead I’ve created a function that will predict new values of prey captured using a functional response formula that is already parameterised.&lt;/p&gt;
&lt;p&gt;Let’s look at the function:&lt;/p&gt;
&lt;hr /&gt;
&lt;div id=&#34;an-interactive-function&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;An interactive function&lt;/h2&gt;
&lt;p&gt;R has some capacity to be interactive. It can ask a user to input variables.
The function &lt;code&gt;functional_response&lt;/code&gt; will return the number of prey captured for a given prey density and type of jar used. The function will ask for these two inputs each time the function is run. Look at the code below and try to understand the different components. Then try running the code yourself with different inputs.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#### Interactive function
# Simulation of the predator-prey functional response - DO NOT CHANGE
# To run: click Source (cmd or ctrl+shift+S) or Run All (ctrl+alt+r)
# Or source(&amp;quot;&amp;lt;insert file location here&amp;gt;&amp;quot;, echo = FALSE)

functional_response &amp;lt;- function(){
  
  # Introduce the simulation to the user - prints a message
  cat(paste(
    &amp;quot;&amp;quot;,
    &amp;quot;You have some counters (prey), a piece of A4 paper &amp;amp; a jar.&amp;quot;,
    &amp;quot;You spread the counters randomly on the A4 sheet.&amp;quot;,
    sep=&amp;quot;\n&amp;quot;))
  
  # Ask the user for the prey density for the functional response
  prey_density  &amp;lt;- readline(&amp;quot;How many prey counters are used? &amp;quot;) # ask for prey density
  
  # Check the user has inputted a number properly
  if(!grepl(&amp;quot;^[0-9]+$&amp;quot;, prey_density)){ # check whether the input contains numeric characters between 0-9 using regex (regular expressions)
    message(&amp;quot;Please enter an integer&amp;quot;) # If the input is not a number, tell them to do it again
    return(functional_response()) # Return to the beginning of the function and start again
  }
  prey_density &amp;lt;- as.integer(prey_density) # If the prey density input is a number, turn it into an interger
  
  # Ask the user for the type of jar used
  cat(paste(
    &amp;quot;&amp;quot;,
    &amp;quot;Every second you (the predator) tap the sheet to find and pick up a prey counter while blindfolded.&amp;quot;,
    &amp;quot;You have 1 minute to put as many prey counters as you can in the jar.&amp;quot;,
    &amp;quot;There are two types of jars you can use while handling prey.&amp;quot;,
    &amp;quot;Enter 1 to use a jar with a lid that you have to open and close.&amp;quot;,
    &amp;quot;Enter 2 to use a jar without a lid.&amp;quot;,
    &amp;quot;&amp;quot;,
    &amp;quot;What type of jar is used?&amp;quot;,
    sep=&amp;quot;\n&amp;quot;))
  lid_used &amp;lt;- menu(c(&amp;quot;Lid&amp;quot;, &amp;quot;No Lid&amp;quot;))
  
  # Calculate the number of prey caught (the functional response) based on the user defined input above
  if(lid_used != 0){ # Check that the use has chosen the jar used properly (1 or 2)
    
    # Use this model if using a jar with a lid
    if(lid_used == 1){
      Ha &amp;lt;- (0.2 * prey_density)/(1 + 0.2 * 0.03 * prey_density) 
    }
    
    # Use this model if using a jar without a lid
    if(lid_used == 2){
      Ha &amp;lt;- (0.7 * prey_density)/(1 + 0.7 * 0.05 * prey_density) 
    }
    
    # Add in some variation around the predicted value so that users don&amp;#39;t get the exact parameterised functional response
    Ha &amp;lt;- Ha + sample(seq(-3,3), 1) 
    
    # Make sure there are no negative prey items caught!
    if(Ha &amp;lt; 0){
      Ha &amp;lt;- 0 # Make prey caught 0 if less than 0
    }
    
    # Make sure the number of prey caught doesn&amp;#39;t exceed the number of prey available!
    if(Ha &amp;gt; prey_density){
      Ha &amp;lt;- prey_density # If prey caught is greater than the number of prey available, make it the maximum possible
    }
    
    # Print a message showing the results
    message(&amp;quot;The number of prey caught is &amp;quot;, floor(Ha), &amp;quot;. Well done!&amp;quot;) 
  }
}

# Actually run the function and tell R that it&amp;#39;s interactive 
if(interactive()) functional_response()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The function doesn’t have any inputs in &lt;code&gt;function()&lt;/code&gt; because it will ask the user for them each time&lt;/li&gt;
&lt;li&gt;&lt;code&gt;readline&lt;/code&gt; is the function to ask for a single user input&lt;/li&gt;
&lt;li&gt;&lt;code&gt;menu&lt;/code&gt; is the function to ask the user to chose from a number of options
&lt;ul&gt;
&lt;li&gt;Here the option is press 1 to use a jar with a lid or press 2 to use a jar without a lid&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;There are two parameterised functional responses - one for a jar with a lid and one for a jar without a lid&lt;/li&gt;
&lt;li&gt;&lt;code&gt;floor&lt;/code&gt; is a function to round the number of prey caught to the lowest whole number&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the practical, students will need to run the above function for 10 prey densities, repeated 3 times, for both jar treatments - so 60 times in total. But we don’t have to do that manually - that is what loops are for!&lt;/p&gt;
&lt;hr /&gt;
&lt;/div&gt;
&lt;div id=&#34;functions-and-loops&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Functions and loops&lt;/h2&gt;
&lt;p&gt;Here is a non-interactive version of the function above. It doesn’t have the printed messages asking for user input. This time, the function needs 3 inputs as indicated by &lt;code&gt;function(prey_density, lid_used, total_time)&lt;/code&gt;: the prey density used, the type of jar used and the total foraging time, respectively.&lt;/p&gt;
&lt;p&gt;Run the code chunk to load the function into the R environment:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Functional response function
functional_response &amp;lt;- function(prey_density, lid_used, total_time){
  
  # Check jar type is inputted correctly
  if (!lid_used %in% c(&amp;quot;yes&amp;quot;, &amp;quot;no&amp;quot;)) {
    stop(&amp;quot;Lid used is not inputted correctly. Use &amp;#39;yes&amp;#39; or &amp;#39;no&amp;#39; in all lowercase&amp;quot;)
  }
  if(lid_used == &amp;quot;yes&amp;quot;){
    Ha &amp;lt;- (0.2 * prey_density * total_time)/(1 + 0.2 * 0.03 * prey_density)
  }
  if(lid_used == &amp;quot;no&amp;quot;){
    Ha &amp;lt;- (0.7 * prey_density * total_time)/(1 + 0.7 * 0.05 * prey_density)
  }
  Ha &amp;lt;- Ha + sample(seq(-3,3), 1)
  if(Ha &amp;lt; 0){
    Ha &amp;lt;- 0
  }
  if(Ha &amp;gt; prey_density){
    Ha &amp;lt;- prey_density
  }
  # message(&amp;quot;The number of prey caught is &amp;quot;, floor(Ha))
return(floor(Ha))
  }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The function will check that the character vector indicating the type of jar to be used is correct because R is case sensitive. The function will return the number of prey caught &lt;code&gt;Ha&lt;/code&gt; as indicated by &lt;code&gt;return(Ha)&lt;/code&gt;. The function &lt;code&gt;return&lt;/code&gt; specifically tells R to tell us the output, otherwise R will keep it to itself! Only one output is allowed (unless extra steps are taken).
The rest of the function is the same.&lt;/p&gt;
&lt;hr /&gt;
&lt;div id=&#34;using-the-functional-response-function-in-a-loop&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Using the functional response function in a loop&lt;/h3&gt;
&lt;p&gt;Now let’s use a loop to do our entire experiment in one go! No manual inputs for us. In fact we can do as many treatments or replicates as we want. Let’s do prey densities between 5 and 100 in increments of 5 and 3 replicates. Since the function inputs are required we can set them up in the environment for the function:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Set parameters for the function
total_time &amp;lt;- 1 # total foraging time in minutes
no_treatments &amp;lt;- seq(from = 5, to = 100, by = 5) # prey density treatments between 5 and 100
replications &amp;lt;- 3 # number of replications

# a numeric vector of prey densities for all treatments, jar types and replications 
prey_density &amp;lt;- rep(rep(no_treatments, replications),2) # repeated twice for each jar type

# a character vector of the jar type
lid_used &amp;lt;- sort(rep(c(&amp;quot;no&amp;quot;, &amp;quot;yes&amp;quot;), length(prey_density)/2)) # &amp;quot;yes&amp;quot; or &amp;quot;no&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By setting up the parameters outside the function or loop, we can easily modify the parameters of the function and feed the new values into the loop. This helps us debug and is cleaner and easier to read.&lt;/p&gt;
&lt;p&gt;Now for the actual loop itself. We need to be able to store the output of the looped function.
Lists are the fastest way to do so in R because R is designed for lists and matrices.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Create an empty list called prey_caught to populate 
prey_caught &amp;lt;- list()

for(i in seq_along(prey_density)){
  # Run the functional response for the nth observation in the vector prey_density representing all our observations and save it to the list
  prey_caught[[i]] &amp;lt;- functional_response(prey_density = prey_density[i],
                                         lid_used = lid_used[i],
                                         total_time = total_time)
  
  # Prepare the list for further analysis
  prey_caught[[i]] &amp;lt;-  cbind(prey_caught[[i]], prey_density[i]) # add a column for the prey density used to calculate the number of prey caught for that observation (row)
  prey_caught[[i]] &amp;lt;-  cbind(prey_caught[[i]], 1/prey_caught[[i]]) # add a column for the inverse of the number of prey caught - for statiscally parameterising the functional response
  prey_caught[[i]][,3] &amp;lt;-  ifelse(prey_caught[[i]][,3] == Inf, 0, prey_caught[[i]][,3]) # Housekeeping - turn undefined values of prey caught (from calculating 1 divided by 0) into 0. If the number of prey caught was 0
}

# Turn our list into a data frame
prey_caught &amp;lt;- data.frame(do.call(&amp;quot;rbind&amp;quot;, prey_caught))

# Label the columns
colnames(prey_caught) &amp;lt;- c(&amp;quot;Ha&amp;quot;, &amp;quot;H&amp;quot;,&amp;quot;Ha.1&amp;quot;, &amp;quot;HT.1&amp;quot;) # &amp;quot;.1 is inversed columns&amp;quot;

# Add type of lid used to our data frame
prey_caught$lid_used &amp;lt;- lid_used&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Here we are using a &lt;code&gt;for&lt;/code&gt; loop with the n&lt;sup&gt;th&lt;/sup&gt; observation denoted &lt;code&gt;i&lt;/code&gt;. This can be called anything you want but &lt;code&gt;i&lt;/code&gt; is from mathematical notation.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;seq_along&lt;/code&gt; is a useful function for telling which observation you are at for a vector - try it out on its own.&lt;/li&gt;
&lt;li&gt;Lists can only contain one variable type, unlike a data frame, but that’s why they are fast and memory efficient for high performance computing
&lt;ul&gt;
&lt;li&gt;If we were to add the jar type (a character vector) to the list within the loop, then all our numeric output will be converted to characters (default R behaviour) - not what we want!&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;do.call&lt;/code&gt; is a handy function for lists. It collapses multidimensional lists into one dimension, here appending them by rows (i.e. adding new observations by rows at the end)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;/div&gt;
&lt;div id=&#34;visualising-the-data&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Visualising the data&lt;/h3&gt;
&lt;p&gt;Now we can plot our results and conduct our linear regression:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyverse)

prey_caught %&amp;gt;% # Absolute values
  ggplot(aes(H, Ha, colour = lid_used)) +
  geom_point() +
  geom_smooth(method = &amp;quot;lm&amp;quot;, se = FALSE, fullrange=TRUE) +
  labs(x = expression(paste(&amp;quot;Prey density  (H)&amp;quot;)),
       y = expression(paste(&amp;quot;Prey captured  (Ha)&amp;quot;)),
       colour = &amp;quot;Jar used&amp;quot;) +
  theme_classic()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://jacintak.github.io/post/2021-06-01-r-function-loops/index_files/figure-html/plot-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Linear model
summary(lm(Ha.1 ~ HT.1 * lid_used, prey_caught))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;
Call:
lm(formula = Ha.1 ~ HT.1 * lid_used, data = prey_caught)

Residuals:
     Min       1Q   Median       3Q      Max 
-0.27245 -0.05371 -0.01596  0.00899  0.84476 

Coefficients:
                 Estimate Std. Error t value Pr(&amp;gt;|t|)   
(Intercept)       0.07136    0.02262   3.155  0.00204 **
HT.1              1.00548    0.40029   2.512  0.01338 * 
lid_usedyes       0.09517    0.03198   2.976  0.00356 **
HT.1:lid_usedyes -1.11833    0.56609  -1.976  0.05058 . 
---
Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1

Residual standard error: 0.1351 on 116 degrees of freedom
Multiple R-squared:  0.08913,   Adjusted R-squared:  0.06558 
F-statistic: 3.784 on 3 and 116 DF,  p-value: 0.01242&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That has saved us from running the code 120 times! Now we can do it in one!&lt;/p&gt;
&lt;hr /&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Formatting P values</title>
      <link>https://jacintak.github.io/post/2021-05-01-formatting-p-values/</link>
      <pubDate>Sat, 01 May 2021 00:00:00 +0000</pubDate>
      <guid>https://jacintak.github.io/post/2021-05-01-formatting-p-values/</guid>
      <description>
&lt;script src=&#34;https://jacintak.github.io/post/2021-05-01-formatting-p-values/index_files/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;p&gt;This &lt;a href=&#34;https://www.r-bloggers.com/2016/03/correctly-reporting-p-values-in-summary-tables-reported-with-xtable/&#34;&gt;post&lt;/a&gt; on R bloggers describes a handy function for formatting really small P values in ANOVA tables (more than 3 decimal places) with &lt;span class=&#34;math inline&#34;&gt;\(&amp;lt;0.001\)&lt;/span&gt;. I find this easier to read when I need to present a formatted table, e.g. in teaching.&lt;/p&gt;
&lt;p&gt;The original function doesn’t cover all ways of creating ANOVA tables in &lt;code&gt;R&lt;/code&gt; so I have extended the function to cover more cases. The &lt;code&gt;fixp&lt;/code&gt; function below will work for ANOVA tables (&lt;code&gt;x&lt;/code&gt;) generated by &lt;code&gt;anova(lm(...))&lt;/code&gt; and &lt;code&gt;summary(aov(lm(...)))&lt;/code&gt;, as well as the model coefficients table generated by &lt;code&gt;coef(summary(lm(...)))&lt;/code&gt;.&lt;/p&gt;
&lt;div id=&#34;a-function-to-format-p-values&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;A function to format P values&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;fixp &amp;lt;- function(x, dig=3){

# Convert to a data frame
  if(is.data.frame(x) | is.matrix(x)){
  x &amp;lt;- as.data.frame(x)
  } else {
  x &amp;lt;- as.data.frame(x[[1]])
  }

# Check column order  
  if(substr(names(x)[ncol(x)],1,2) != &amp;quot;Pr&amp;quot;){
    warning(&amp;quot;The name of the last column didn&amp;#39;t start with Pr. This may indicate that p-values weren&amp;#39;t in the last row, and thus, that this function is inappropriate.&amp;quot;)
    }
    
# Round P values to &amp;quot;dig&amp;quot; decimal places, default 3     
  x[,ncol(x)] &amp;lt;- round(x[,ncol(x)], dig)

#  
  for(i in 1:nrow(x)){
    if(x[i,ncol(x)] == 0 &amp;amp; !is.na(x[i,ncol(x)])){
      x[i,ncol(x)] &amp;lt;- paste0(&amp;quot;&amp;lt;0.&amp;quot;, paste0(rep(0,dig-1), collapse=&amp;quot;&amp;quot;), &amp;quot;1&amp;quot;)
      }
  }
  x
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The main modification to the original function is to expand the conversion of &lt;code&gt;x&lt;/code&gt; to a data frame to accept lists and matrices. &lt;code&gt;summary(aov(lm(...)))&lt;/code&gt; creates an object with class &lt;code&gt;summary.aov&lt;/code&gt; which is a list and the coefficients table is a matrix. Although &lt;code&gt;anova(lm(...))&lt;/code&gt; creates a data frame that will work with the function without a fatal error, the function &lt;code&gt;anova&lt;/code&gt; has its own way of “pretty” printing [to quote the help file] which is not compatible with the character vector in the P value column and thus will show a P value of 1. So forcing to a data frame is necessary. A minor modification is to ignore the NAs in the Residual row created by the data frame which would otherwise give an error.&lt;/p&gt;
&lt;p&gt;The three decimal places for P values is coded into the function by default and can be changed by the &lt;code&gt;dig&lt;/code&gt; option. For example, &lt;code&gt;dig = 1&lt;/code&gt; will give you &lt;span class=&#34;math inline&#34;&gt;\(&amp;lt;0.1\)&lt;/span&gt;. You can then call your ANOVA table and the &lt;code&gt;fixp&lt;/code&gt; function through &lt;code&gt;knitr::kable()&lt;/code&gt; or your favourite HTML/LaTeX table formatter. e.g. &lt;code&gt;kable(fixp(anova(lm(...))), digits = ...)&lt;/code&gt;. If you don’t want to print NAs, it’s probably better to use the options in your chosen formatting function - e.g. the &lt;code&gt;knitr.kable.NA&lt;/code&gt; option in &lt;a href=&#34;https://bookdown.org/yihui/rmarkdown-cookbook/kable.html&#34;&gt;&lt;code&gt;kable&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Leaving the valley of intermediate competence</title>
      <link>https://jacintak.github.io/post/2021-03-01-replacing-for-loops-with-apply/</link>
      <pubDate>Mon, 01 Mar 2021 00:00:00 +0000</pubDate>
      <guid>https://jacintak.github.io/post/2021-03-01-replacing-for-loops-with-apply/</guid>
      <description>
&lt;script src=&#34;https://jacintak.github.io/post/2021-03-01-replacing-for-loops-with-apply/index_files/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;div id=&#34;if-it-aint-broke-dont-fix-it&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;If it ain’t broke, don’t fix it?&lt;/h1&gt;
&lt;p&gt;So you’ve spent a lot of time learning and practising &lt;code&gt;R&lt;/code&gt; and you’re pretty comfortable with using functions, if else statements and loops like they teach at introductory programming. What more is there to improve?&lt;/p&gt;
&lt;p&gt;If the answer is no or you subscribe to the quote above, then turn back now. If yes, continue.&lt;/p&gt;
&lt;p&gt;I think that even if one has the skills to do fundamental programming competently, there’s always room for improvement or something new to learn. Or you know that there’s a better, more efficient, way to do it but something is holding you back. For me, it’s usually the latter.&lt;/p&gt;
&lt;p&gt;In a milestone of using &lt;code&gt;R&lt;/code&gt; I think I have wrapped my head around replacing for loops with the &lt;code&gt;apply&lt;/code&gt; family, specifically &lt;code&gt;mapply&lt;/code&gt;. The last hurdle in delving into functional programming.&lt;/p&gt;
&lt;p&gt;I’ve used iterative coding quite a bit over the years and I’ve been using for loops to do so. As I’ve gotten more competent with applying basic concepts (like loops and functions), I’ve been moving towards optimising my code with more advanced &lt;code&gt;R&lt;/code&gt; methods. I started with using more manual functions and sourcing functions from external scripts but I was still relying on loops to apply those functions iteratively.&lt;/p&gt;
&lt;p&gt;I know loops are inefficient. I’ve waited &lt;em&gt;days&lt;/em&gt; for computationally intensive loops on large datasets to finish. I know that &lt;code&gt;apply&lt;/code&gt; and co. can be more computationally efficient but in your typical learning something new way, they hadn’t really clicked for me…until now.&lt;/p&gt;
&lt;p&gt;I’ve been trying to use &lt;code&gt;apply&lt;/code&gt; family functions where appropriate for years but I’ve never felt comfortable with using them to use them from the start. So, I default back to loops to save time and frustration.&lt;/p&gt;
&lt;p&gt;I think the slow uptake is because the syntax is different to the logic of loops that are taught, even if &lt;code&gt;apply&lt;/code&gt;’s logic is better from a computing perspective. The syntax and the logic is also inconsistent within the &lt;code&gt;apply&lt;/code&gt; family; a known disadvantage over similar functions (like &lt;code&gt;purrr::map&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;But let’s focus on a specific case before this becomes a cooking blog: replacing for loops. I’m going to assume that you are competent with manual functions, for loops and lists, and that you want to improve your code. I’m going to focus on lists because they are an efficient way of storing lots of similarly structured data in &lt;code&gt;R&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Here are two ways to replace a for loop.&lt;/p&gt;
&lt;hr /&gt;
&lt;/div&gt;
&lt;div id=&#34;an-example-loop&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;An example loop&lt;/h1&gt;
&lt;p&gt;Let’s create an example scenario and data:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# some data to use
loop_data &amp;lt;- data.frame(col1 = c(11:15), col2 = c(20:24))

# define variable to change
a &amp;lt;- seq(0.2, 1, 0.2)&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;loop_data&lt;/code&gt; is a data frame with two numeric columns (&lt;code&gt;col1&lt;/code&gt; &amp;amp; &lt;code&gt;col2&lt;/code&gt;). We technically won’t use &lt;code&gt;loop_data$col2&lt;/code&gt; but it’s there to create a 5x2 data frame.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt; is a variable that we need for our function. There are 5 values.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We want to add each element of &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;loop_data$col1&lt;/code&gt; and save that in a new column &lt;code&gt;loop_data$col1a&lt;/code&gt;. We will also add &lt;code&gt;a&lt;/code&gt; as a column in &lt;code&gt;loop_data&lt;/code&gt; just so we can keep track of which value was used to calculate &lt;code&gt;col1a&lt;/code&gt;. So the final output should have 25 rows (5 observations in &lt;code&gt;loop_data&lt;/code&gt; x 5 values of &lt;code&gt;a&lt;/code&gt;) and 4 columns (&lt;code&gt;col1&lt;/code&gt;, &lt;code&gt;col2&lt;/code&gt;, &lt;code&gt;col1a&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;We will be storing our data in lists in all our scenarios. Note that I create the list to hold the answers (&lt;code&gt;loop_ans&lt;/code&gt;) before the function rather than to append newly calculated answers sequentially to the list within the function. I use the same &lt;code&gt;replicate&lt;/code&gt; function before all the examples. You could also start with an empty list.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# data sets stored as a list - must not simplify or it will reduce to a matrix!
loop_ans &amp;lt;- replicate(length(a), loop_data, simplify = FALSE)

# A function to add a value a to a data frame x
loop_function &amp;lt;- function(x, a) {
  x$col1a &amp;lt;- x$col1 + a # add answer to a new column 
  x$a &amp;lt;- a # add a to a new column
  return(x) # give us the updated data frame
}

# Let&amp;#39;s loop
for(i in seq_along(a)){
  loop_ans[[i]] &amp;lt;- loop_function(loop_ans[[i]], a = a[i]) 
}

# merge to single data frame
loop_ans &amp;lt;- do.call(rbind, loop_ans)

# view the data
summary(loop_ans)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##       col1         col2        col1a            a      
##  Min.   :11   Min.   :20   Min.   :11.2   Min.   :0.2  
##  1st Qu.:12   1st Qu.:21   1st Qu.:12.4   1st Qu.:0.4  
##  Median :13   Median :22   Median :13.6   Median :0.6  
##  Mean   :13   Mean   :22   Mean   :13.6   Mean   :0.6  
##  3rd Qu.:14   3rd Qu.:23   3rd Qu.:14.8   3rd Qu.:0.8  
##  Max.   :15   Max.   :24   Max.   :16.0   Max.   :1.0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That’s the loop - should be familiar to you. Merging into a single data frame is optional if you want to keep using lists. Now let’s look at &lt;code&gt;lapply&lt;/code&gt; for a less elegant solution (!).&lt;/p&gt;
&lt;hr /&gt;
&lt;/div&gt;
&lt;div id=&#34;lapply&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;1. &lt;code&gt;lapply&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;lapply&lt;/code&gt; takes a list as input, does stuff and gives a list as output. Hence, the l in &lt;code&gt;lapply&lt;/code&gt; stands for list. The difference with loops and &lt;code&gt;lapply&lt;/code&gt; is that &lt;code&gt;lapply&lt;/code&gt; can only take one input - your data frame (or element in list). This means that we need to add the corresponding value of &lt;code&gt;a&lt;/code&gt; as a column in each element of &lt;code&gt;lapply&lt;/code&gt; - in other words to do part of what &lt;code&gt;loop_function&lt;/code&gt; did but outside the loop/&lt;code&gt;lapply&lt;/code&gt;. Thus, each data frame in the input list should have three columns: &lt;code&gt;col1&lt;/code&gt;, &lt;code&gt;col2&lt;/code&gt; &amp;amp; &lt;code&gt;a&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Incidentally, we can add the corresponding &lt;code&gt;a&lt;/code&gt; value as a column using &lt;code&gt;mapply&lt;/code&gt; and &lt;code&gt;cbind&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# the function only accepts one element: x
lapply_function &amp;lt;- function(x){
  x$col1a &amp;lt;- x$col1 + x$a
  return(x)
}

# Prepare the answer list
lapply_ans &amp;lt;- replicate(length(a), loop_data, simplify = FALSE)

# add a column using mapply
lapply_ans &amp;lt;- mapply(FUN = cbind, lapply_ans, &amp;quot;a&amp;quot; = a, SIMPLIFY = FALSE)

# apply function
lapply_ans &amp;lt;- lapply(lapply_ans, FUN = lapply_function)

# merge to single data frame
lapply_ans &amp;lt;- do.call(rbind, lapply_ans)

# view the data
summary(lapply_ans)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##       col1         col2          a           col1a     
##  Min.   :11   Min.   :20   Min.   :0.2   Min.   :11.2  
##  1st Qu.:12   1st Qu.:21   1st Qu.:0.4   1st Qu.:12.4  
##  Median :13   Median :22   Median :0.6   Median :13.6  
##  Mean   :13   Mean   :22   Mean   :0.6   Mean   :13.6  
##  3rd Qu.:14   3rd Qu.:23   3rd Qu.:0.8   3rd Qu.:14.8  
##  Max.   :15   Max.   :24   Max.   :1.0   Max.   :16.0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you see it’s not as simple as the loop or &lt;code&gt;mapply&lt;/code&gt; and requires &lt;code&gt;mapply&lt;/code&gt; anyway :shrug:&lt;br /&gt;
So we can do better…&lt;/p&gt;
&lt;hr /&gt;
&lt;/div&gt;
&lt;div id=&#34;mapply&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;2. &lt;code&gt;mapply&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;The m in &lt;code&gt;mapply&lt;/code&gt; stands for multiple because it takes multiple arguments and applies them to the data. There are some key differences in the structure of the data and the function compared to &lt;code&gt;lapply&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We can use the original loop function with two variables!
&lt;ul&gt;
&lt;li&gt;The additional variables (&lt;code&gt;a&lt;/code&gt; in this example) are written after the function &lt;code&gt;FUN&lt;/code&gt; is defined in &lt;code&gt;mapply&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;We can also use the original list (&lt;code&gt;loop_data&lt;/code&gt;) without further modification!&lt;/li&gt;
&lt;li&gt;We need to tell &lt;code&gt;mapply&lt;/code&gt; not to simplify the output into a matrix by default. Note the use of upper case in &lt;code&gt;SIMPLIFY&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Prepare the answer list
mapply_ans &amp;lt;- replicate(length(a), loop_data, simplify = FALSE)
# mapply function
mapply_ans &amp;lt;- mapply(mapply_ans, FUN = loop_function, a = a, SIMPLIFY = FALSE)
# merge to single data frame
mapply_ans &amp;lt;- do.call(rbind, mapply_ans)
# view the data
summary(mapply_ans)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##       col1         col2        col1a            a      
##  Min.   :11   Min.   :20   Min.   :11.2   Min.   :0.2  
##  1st Qu.:12   1st Qu.:21   1st Qu.:12.4   1st Qu.:0.4  
##  Median :13   Median :22   Median :13.6   Median :0.6  
##  Mean   :13   Mean   :22   Mean   :13.6   Mean   :0.6  
##  3rd Qu.:14   3rd Qu.:23   3rd Qu.:14.8   3rd Qu.:0.8  
##  Max.   :15   Max.   :24   Max.   :16.0   Max.   :1.0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What &lt;code&gt;mapply&lt;/code&gt; is doing is using the n&lt;sup&gt;th&lt;/sup&gt; element of &lt;code&gt;a&lt;/code&gt; with the corresponding n&lt;sup&gt;th&lt;/sup&gt; element in the list &lt;code&gt;loop_data&lt;/code&gt;. So the fifth value of &lt;code&gt;a&lt;/code&gt; (1.0) is used in the calculations on the 5th data frame in &lt;code&gt;loop_data&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We’ve replace the for loop with a &lt;code&gt;mapply&lt;/code&gt; function! :clap:&lt;br /&gt;
Here’s to functional programming. Next up is &lt;code&gt;purrr::map&lt;/code&gt;…&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Transparent graphing for dark backgrounds</title>
      <link>https://jacintak.github.io/post/2021-02-01-transparent-graphing-for-dark-backgrounds/</link>
      <pubDate>Mon, 01 Feb 2021 00:00:00 +0000</pubDate>
      <guid>https://jacintak.github.io/post/2021-02-01-transparent-graphing-for-dark-backgrounds/</guid>
      <description>
&lt;script src=&#34;https://jacintak.github.io/post/2021-02-01-transparent-graphing-for-dark-backgrounds/index_files/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;p&gt;I’m not usually a dark background person but I’m open to the dark side. I wanted to make a solid coloured graph with a transparent background that would show up nicely but &lt;code&gt;ggplot2&lt;/code&gt; doesn’t have a set theme for that. A clean solid fill and transparency requires some specific customisation so here is a reproducible example for you using the built-in &lt;code&gt;trees&lt;/code&gt; dataset:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tree_graph &amp;lt;- ggplot(data = trees, 
       mapping = aes(x = Height, 
                     y = Girth)) + 
    geom_point(size = 0.5, colour = &amp;quot;#B8DE29FF&amp;quot;) + 
    geom_smooth(method = &amp;quot;lm&amp;quot;, se = FALSE, col = &amp;quot;#B8DE29FF&amp;quot;) + 
    geom_abline(intercept = 0, slope = 1, col = &amp;quot;white&amp;quot;, lwd = 0.5, lty = 2) + 
    theme_classic() +
    theme(plot.background = element_rect(fill = &amp;quot;transparent&amp;quot;, color = NA),
          panel.background = element_rect(fill = &amp;quot;transparent&amp;quot;),
          axis.text = element_text(colour = &amp;quot;#B8DE29FF&amp;quot;, size = 8),
          axis.title = element_text(colour = &amp;quot;#B8DE29FF&amp;quot;, size = 8),
          axis.line = element_line(colour = &amp;quot;#B8DE29FF&amp;quot;),
          axis.ticks = element_line(colour = &amp;quot;#B8DE29FF&amp;quot;))

ggsave(tree_graph, filename = &amp;quot;tree_graph.png&amp;quot;, bg = &amp;quot;transparent&amp;quot;, type = &amp;quot;cairo&amp;quot;, width = 10, height = 10, dpi = 300)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are a couple of generally useful elements added on purpose:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;geom_smooth&lt;/code&gt; creates an automatically fitted linear model (defined using &lt;code&gt;method = &#34;lm&#34;&lt;/code&gt;). I have turned off plotting the standard errors (on by default) and manually set the colour.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;geom_abline&lt;/code&gt; is your standard straight line&lt;/li&gt;
&lt;li&gt;&lt;code&gt;theme&lt;/code&gt; is where the customisation begins:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;plot.background&lt;/code&gt; &amp;amp; &lt;code&gt;panel.background&lt;/code&gt; are set to transparent&lt;/li&gt;
&lt;li&gt;The various axis elements are set to the fill colour (a nice &lt;code&gt;viridis&lt;/code&gt; green) and desired text size&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ggsave&lt;/code&gt; specifies that the background is transparent and to save it using the Cairo engine (&lt;code&gt;type = &#34;cairo&#34;&lt;/code&gt;). Cairo will create a vector based image so resizing the png isn’t an issue since the small font size is already defined.
&lt;ul&gt;
&lt;li&gt;You can also use &lt;code&gt;cairo-png&lt;/code&gt; but the graph height and width options appear to be ignored.&lt;/li&gt;
&lt;li&gt;If you don’t save it as a Cairo png, then the text will still have a white outline and won’t be a clean solid fill&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
