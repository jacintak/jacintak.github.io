---
title: Replacing for loops with apply
author: admin
date: '`r Sys.Date()`'
slug: []
categories: [code]
tags: [R stats, code]
subtitle: ''
summary: ''
authors: []
lastmod: '2020-12-15T00:39:22Z'
publishDate: ""
draft: true
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
---

# Leaving the valley of intermediate competence

> If it ain't broke, don't fix it

So you've spent a lot of time learning and practising `R` and you're pretty comfortable with using functions, if else statements and loops like they teach at introductory programming. What more is there to improve?

If the answer is no or you subscribe to the quote above, then turn back now. If yes, continue. 

I think that even if one has the skills to do fundamental programming competently, there's always room for improvement or something new to learn. Or you know that there's a better, more efficient, way to do it but something is holding you back. For me, it's usually the latter.

In a milestone of using `R` I think I have wrapped my head around replacing for loops with the `apply` family, specifically `mapply`. The last hurdle in delving into functional programming.

I've used iterative coding quite a bit over the years and I've been using for loops to do so. As I've gotten more competent with applying basic concepts (like loops and functions), I've been moving towards optomising my code with more advanced `R` methods. I started with using more manual functions and sourcing functions from external scripts but I was still relying on loops to apply those functions iretatively.

I know loops are inefficient. I've waited *days* for computationally intensive loops on large datasets to finish. I know that `apply` and co. can be more computationally efficient memory-wise but in your typical learning something new way, they hadn't really clicked for me...until now.

I've been trying to use `apply` family functions where appropriate for years but I've never felt comfortable with using them to use them from the start. So, I default back to loops to save time and frustration.  

I think the slow uptake is because the syntax is different to the logic of loops that are taught, even if `apply`'s logic better from a computing perspective. The syntax and the logic is also inconsistent within the `apply` family; a known disadvantage over similar functions (like `purrr::map`). 

But let's focus on a specific case before this becomes a cooking blog: replacing for loops. I'm going to assume that you are comptent with manual functions, for loops and lists, and that you want to improve your code. I'm going to focus on lists because they are an efficient way of storing data in `R`. Here are two ways to replace a for loop:

# An example loop

Here's an example of a loop that we want to replace. It should be familiar to you as a general loop involving saving output to a list while keeping the original values and noting the . For example, a sensitivity analysis where we want to change parameter values.

```{r loop}
loop_function <- function(x) return(x$A + x$B) # A function
# 3 data sets stored as a list
loop_data <- replicate(3, list(data.frame(A = c(11:15), B = c(20:24))))

loop_ans <- loop_data
for(i in seq_along(loop_data)){
  loop_ans [[i]]$C <- loop_function(loop_data[[i]]) # apply the function
}
loop_ans
```

# 1. `lapply`

`lapply` takes a list as input, does stuff and gives a list as output. Hence, `l apply` for list. The key with using `lapply` is that you need to prepare the input data in a specific way. For example, you need to have the parameter you change within the list and the function applied to the list only takes one element - the list.

```{r lapply}
lapply(loop_data, FUN = loop_function)
```



Replacing the above is simple with if you don't want to include the original

# 2. `mapply`

The m in `mapply` stands for multiple because it takes multiple arguments and applies them to the data.