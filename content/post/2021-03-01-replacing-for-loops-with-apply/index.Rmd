---
title: "Replacing for loops with apply"
author: "admin"
date: ''
slug: []
categories: code
tags:
- R stats
- code
subtitle: ''
summary: ''
authors: []
publishDate: ''
draft: yes
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
editor_options: 
  chunk_output_type: console
---

# Leaving the valley of intermediate competence

> If it ain't broke, don't fix it

So you've spent a lot of time learning and practising `R` and you're pretty comfortable with using functions, if else statements and loops like they teach at introductory programming. What more is there to improve?

If the answer is no or you subscribe to the quote above, then turn back now. If yes, continue. 

I think that even if one has the skills to do fundamental programming competently, there's always room for improvement or something new to learn. Or you know that there's a better, more efficient, way to do it but something is holding you back. For me, it's usually the latter.

In a milestone of using `R` I think I have wrapped my head around replacing for loops with the `apply` family, specifically `mapply`. The last hurdle in delving into functional programming.

I've used iterative coding quite a bit over the years and I've been using for loops to do so. As I've gotten more competent with applying basic concepts (like loops and functions), I've been moving towards optomising my code with more advanced `R` methods. I started with using more manual functions and sourcing functions from external scripts but I was still relying on loops to apply those functions iretatively.

I know loops are inefficient. I've waited *days* for computationally intensive loops on large datasets to finish. I know that `apply` and co. can be more computationally efficient memory-wise but in your typical learning something new way, they hadn't really clicked for me...until now.

I've been trying to use `apply` family functions where appropriate for years but I've never felt comfortable with using them to use them from the start. So, I default back to loops to save time and frustration.  

I think the slow uptake is because the syntax is different to the logic of loops that are taught, even if `apply`'s logic better from a computing perspective. The syntax and the logic is also inconsistent within the `apply` family; a known disadvantage over similar functions (like `purrr::map`). 

But let's focus on a specific case before this becomes a cooking blog: replacing for loops. I'm going to assume that you are comptent with manual functions, for loops and lists, and that you want to improve your code. I'm going to focus on lists because they are an efficient way of storing data in `R`. 

Here are two ways to replace a for loop.

***

# An example loop

Let's create an example scenario and data:

* `loop_data` is a dataframe with two numeric columns. We technically won't use `loop_data$col2` but it's there to create a 5x2 data frame.
* `a` a variable that we need for our function. There are 5 values.

The function that we want to do is add each element of `a` to `loop_data$col1` and save that in a new column `loop_data$col1a`. We also want to add `a` as a column in `loop_data`. So the final output should have 25 rows (5 observations in `loop_data` x 5 values of `a`) and 4 columns (`col1`, `col2`, `col1a`, `a`).


```{r data}
# some data to use
loop_data <- data.frame(col1 = c(11:15), col2 = c(20:24))

# data sets stored as a list - must not simplify or it will reduce to a matrix!
loop_data <- replicate(length(a), loop_data, simplify = FALSE)

# define variable to change
a <- seq(0.2, 1, 0.2)
```

We will be storing our data in lists in all our scenarios. Note that I created the list before the function rather than use the function to sequentially add to the list. You could start with an empty list.

```{r loop}
# A function
loop_function <- function(x, a) {
  x$col1a <- x$col1 + a
  x$a <- a
  return(x)
}

loop_ans <- loop_data

# Let's loop
for(i in seq_along(a)){
  loop_ans[[i]] <- loop_function(loop_ans[[i]], a = a[i]) 
}

# merge to single data frame
loop_ans <- do.call(rbind, loop_ans)

# view the data
summary(loop_ans)
```

That's the loop - should be familiar to you. Now let's look at `lapply` for a less elegant solution (!).

***

# 1. `lapply`

`lapply` takes a list as input, does stuff and gives a list as output. Hence, the l in `lapply` stands for list. The key with using `lapply` is that you need to prepare the input data in a specific way because the function used with `lapply` can only take one input - your data frame (or element in list). This means that we need to add the corresponding value of `a` as a column in each element of `lapply` - in other words to do part of what `loop function` did but outside the loop/`lapply`. Thus, each data frame in the list should have three columns: `col1`, `col2` & `a`.

Incidentally, we can add the corresponding `a` value as a column using `mapply` and `cbind`.

```{r lapply}
lapply_function <- function(x){
  x$col1a <- x$col1 + x$a
  return(x)
}

lapply_ans <- loop_data

# add column ausing mapply
lapply_ans <- mapply(FUN = cbind, lapply_ans, "a" = a, SIMPLIFY = FALSE)

# apply function
lapply_ans <- lapply(lapply_ans, FUN = lapply_function)

# merge to single data frame
lapply_ans <- do.call(rbind, lapply_ans)

# view the data
summary(lapply_ans)
```

As you see it's not as simple as the loop or `mapply` and requires `mapply` anyway :shrug:  
So we can do better...

***

# 2. `mapply`

The m in `mapply` stands for multiple because it takes multiple arguments and applies them to the data. There are some key differences in the structure of the data and the function compared to `lapply`:

* We can use the original loop function with two variables!
    * The additional variables (`a` in this example) placed after the function `FUN` are passed to the function 
* We can also use the original list (`loop_data`) without further modification!
* We need to tell `mapply` not to simplify the output into a matrix by default. Note the use of uppercase in `SIMPLIFY`.

```{r mapply}
mapply_ans <- loop_data
# apply function
mapply_ans <- mapply(mapply_ans, FUN = loop_function, a = a, SIMPLIFY = FALSE)
# merge to single data frame
mapply_ans <- do.call(rbind, mapply_ans)
# view the data
summary(mapply_ans)
```

What `mapply` is doing is using the n^th^ element of `a` with the corresponding n^th^ element in the list `loop_data`. So the fifth value of `a` (1.0) is used in the calculations on the 5th data frame in `loop data`.

We've replace the for loop with a `mapply` function! :clap:  
Here's to functional programming. Next up is `purrr::map`...